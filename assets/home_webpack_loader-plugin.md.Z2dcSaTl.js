import{_ as a,c as e,o,a4 as t}from"./chunks/framework.BpfaKnQN.js";const b=JSON.parse('{"title":"Loader和Plugin","description":"","frontmatter":{},"headers":[],"relativePath":"home/webpack/loader-plugin.md","filePath":"home/webpack/loader-plugin.md","lastUpdated":1721303702000}'),r={name:"home/webpack/loader-plugin.md"},l=t('<h1 id="loader和plugin" tabindex="-1">Loader和Plugin <a class="header-anchor" href="#loader和plugin" aria-label="Permalink to &quot;Loader和Plugin&quot;">​</a></h1><h2 id="loader" tabindex="-1">Loader <a class="header-anchor" href="#loader" aria-label="Permalink to &quot;Loader&quot;">​</a></h2><p>直译为&quot;加载器&quot;。Webpack 将一切文件视为模块，但是webpack原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 <code>loader</code>。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。</p><h2 id="plugin" tabindex="-1">Plugin <a class="header-anchor" href="#plugin" aria-label="Permalink to &quot;Plugin&quot;">​</a></h2><p>直译为&quot;插件&quot;。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>',5),n=[l];function d(i,c,p,u,s,_){return o(),e("div",null,n)}const g=a(r,[["render",d]]);export{b as __pageData,g as default};
